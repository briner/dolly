#!/usr/bin/python
# -*- coding: utf-8 -*-

# dowloaded at https://github.com/briner/dolly
# all the documentation on https://github.com/briner/dolly/blob/master/dolly/README

# zone-test2
# rsync -a /home/briner/ws2/libcbr_0.2/src/libcbr/ su@zone-test2:/usr/local/lib/python/libcbr_0.2/libcbr/ & scp /home/briner/code/dolly/dolly/src/dolly su@zone-test2:/usr/local/bin ; date


# import
#
import os, sys
sys.path.insert(0,'/usr/local/lib/python/libcbr_0.2/')
import traceback
from datetime import datetime
import re
import signal
import logging
import subprocess
import select
import libcbr # dowloaded from https://github.com/briner/libcbr
from libcbr.iso8601 import parse as iso8601_parse
from libcbr.dateutil.relativedelta import relativedelta
my_logger=logging.getLogger('MyLogger')


###############################################################################
# DEFINITION

#
# definition DEBUG
DEBUG=['lzfs','clean','_clone_n_mount', '_snap', 'unmount_n_unclone','dolly_garbage_collector', 'populate','populate_ldolly']
DEBUG=[]
def print_debug(*args):
    name=args[0]
    if name in DEBUG:
        args=[repr(arg).replace('\\n','\n%s ' % name) for arg in args[1:]]
        print name+' '+' '.join(args)

# definition PELE MELE
LOG_FILENAME='/var/log/dolly'
DOLLY_PATH='/dolly'

MEL_SENDER='unix-noreply@unige.ch'
LEMAIL_ROOT=['unix-bot@unige.ch']
#
# definition backup
DEFAULT_SNAPSHOT_ISO8601_STR="P7D" # tells how long a snapshot will be kept
DEFAULT_MOUNTPOINT='/dolly/backup'
# the 4 the following definitions are string which could be a list like /path/to/zfs1,/path/to/zfs2
SUB_ZFS_DIR_INCL='/'     # or
SUB_ZFS_DIR_EXCL=''     # or
ZFS_DIR_EXCL=""
ZFS_DIR_INCL=""
ZFS_DIR_DONT_KEEP_SNAPSHOT=""
SUB_ZFS_DIR_DONT_KEEP_SNAPSHOT=""
ZPOOL_NAME_INCL=""
ZPOOL_NAME_EXCL=""

#
MUST_RELOAD=False
#
VAR_DIR='/var/run'
LOCKNAME_FORMAT="%(mountpoint_reldir)s.lock"
#
#  definition SNAPNAME
DOLLY_PREFIX='dolly'
RE_IS_A_DOLLY_ZFS=re.compile('/dolly_[^/]+$')
SNAPNAME_FORMAT=DOLLY_PREFIX+'_mnt::%(datetime)s::%(zonename)s'
def is_a_dolly_zfs(zfs):
    return bool(RE_IS_A_DOLLY_ZFS.search(zfs.name))  
#
# definition DATETIME
DATETIME_FORMAT='%Y.%m.%d_%H:%M:%S.%f'
DATE_FORMAT='%Y%m%d'
RE_DATE=re.compile('^(?P<year>\d+)\.(?P<month>\d+)\.(?P<day>\d+)_(?P<hour>\d+):(?P<minute>\d+):(?P<seconde>\d+).(?P<micro>\d+)$')
def str2datetime(date_str):
    year, month, day, hour, minute, seconde, micro=[int(elem) for elem in RE_DATE.match(date_str).groups()]
    date=datetime(year, month, day, hour, minute, seconde, micro)
    return date
def datetime2str(date_time):
    return date_time.strftime(DATETIME_FORMAT)
#
# destroy_dolly_snap
ZFSDESTROY_R_CMD="zfs destroy -R %s"

#
# definition ZONENAME
ZONENAME=libcbr.zone.get_zonename()
ZONE=libcbr.zone.get_zone_by_name(ZONENAME)
LRECIPIENT=ZONE.lrecipient


###############################################################################
###############################################################################
###############################################################################
# CODE
def is_zfs_mounted(zfs):
    if not zfs.get_mountpoint_from_lmount():
        print_debug('lzfs', ' ko : zfs(%s) has no mountpoint : skip it' % (zfs.name))
        return False
    return True
def is_created_by_dolly(snap_or_zfs):
    is_created_by_dolly=snap_or_zfs.duser_prop_value.get('ch.unige:created_by')==DOLLY_PREFIX
    if is_created_by_dolly:
        print_debug('lzfs', ' ko : zfs(%s) was created by dolly : skip it' % (snap_or_zfs.name))
    return is_created_by_dolly
def is_on_a_zone_when_in_globalzone(zfs):
    if ZONENAME == 'global':
        if zfs.zoned=='on':
            return True
    return False
def is_zfs_eligible(zfs):
    #
    if not is_zfs_mounted(zfs):
        return False
    if is_created_by_dolly(zfs):
        return False
    if is_on_a_zone_when_in_globalzone(zfs):
        return False
    if zfs.type != "filesystem":
        return False
    return True

def destroy_dolly_snap(name):
    if name.find("@dolly")==-1:
        raise Exception("destroy_dolly_snap argument name(%s) is not a dolly snapname" % name)
    inst_cmd=ZFSDESTROY_R_CMD % name
    my_logger.debug('zfs destroy -R cmd(%s):' % inst_cmd)
    proc=subprocess.Popen(inst_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, cwd='/')
    lstdout=proc.stdout.readlines()
    lstderr=proc.stderr.readlines()
    proc.communicate()
    retcode=proc.wait()
    if retcode != 0:
        lmsg=['the cmd (%s) did not succeed' % inst_cmd]
        for line in lstdout:
            lmsg.append(' - stdout: %s' % line.rstrip())
        for line in lstderr:
            lmsg.append(' - stderr: %s' % line.rstrip())
        libcbr.notification.notify.add(lmsg)
        for msg in lmsg:
            my_logger.error(msg)
        raise Exception( 'zfs destroy dolly snap problem')
 
def destroy_dolly_zfs(zfs):
    name=zfs.name
    if not is_a_dolly_zfs(zfs):
        raise Exception("destroy_dolly_zfs argument name(%s) is not a dolly zfs" % name)
    inst_cmd=ZFSDESTROY_R_CMD % name
    my_logger.debug('zfs destroy -R cmd(%s):' % inst_cmd)
    proc=subprocess.Popen(inst_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, cwd='/')
    lstdout=proc.stdout.readlines()
    lstderr=proc.stderr.readlines()
    proc.communicate()
    retcode=proc.wait()
    if retcode != 0:
        lmsg=['the cmd (%s) did not succeed' % inst_cmd]
        for line in lstdout:
            lmsg.append(' - stdout: %s' % line.rstrip())
        for line in lstderr:
            lmsg.append(' - stderr: %s' % line.rstrip())
        libcbr.notification.notify.add(lmsg)
        for msg in lmsg:
            my_logger.error(msg)
        raise Exception( 'zfs destroy dolly zfs problem')


    

def dolly_garbage_collector(now, mountpoint):
    my_logger.info('start dolly_garbage_collector')
    my_logger.debug('dolly_garbage_collector on lzpool(%s)' % ','.join([zpool.name for zpool in libcbr.zfs.get_lzpool()]))
    for zpool in libcbr.zfs.get_lzpool():
        my_logger.info('destroy_old_snapshot_kept for zpool(%s)' % zpool.name)
        print_debug ('dolly_garbage_collector', '====ZPOOL(%s)' % zpool.name)
        #
        # lock on zpool
        zpool_unlock=libcbr.stackfunction.stack_function.add(
            zpool.unlock_it,                                                      
            title="unlock file'semaphore of zpool(%s)" % zpool.name,
            group='daemon')
        zpool.lock_it()
        #
        # repopulate all
        libcbr.zfs.populate_lzfs()
        libcbr.zfs.populate_lsnapshot()
        libcbr.mount.populate_lmount()
        #
        # find all the clone that are not mounted and destroy them
        lzfs_clone_unmounted=[]
        lzfs=libcbr.zfs.get_lzfs()
        lzfs_in_zpool=[zfs for zfs in lzfs if zfs.zpool==zpool]
        for zfs in lzfs_in_zpool:
            if not is_created_by_dolly(zfs):
                continue
            if is_zfs_mounted(zfs):
                continue
            lzfs_clone_unmounted.append(zfs)
        for zfs in lzfs_clone_unmounted:
            libcbr.zfs.populate_lzfs()
            if libcbr.zfs.get_lzfs().by_name(zfs.name):
                destroy_dolly_zfs(zfs)
        #
        # repopulate all
        libcbr.zfs.populate_lzfs()
        libcbr.zfs.populate_lsnapshot()
        libcbr.mount.populate_lmount()
        #
        # find all the snapshot, which are unrelated to a clone and created by dolly
        lsnap_to_destroy=[]
        lzfs_in_zpool=[zfs for zfs in libcbr.zfs.get_lzfs() if zfs.zpool==zpool]
        # dsnap_lzfs is created for not using zfs.lclone which is time consuming
        dsnap_lzfs={}
        for zfs in lzfs_in_zpool:
            if zfs.origin:
                if dsnap_lzfs.get(zfs.origin):
                    dsnap_lzfs.append(zfs)
                else:
                    dsnap_lzfs[zfs.origin]=[zfs]
        lsnap_in_zpool=[snap for snap in libcbr.zfs.get_lsnapshot() if snap.zfs.zpool == zpool]
        for snap in lsnap_in_zpool:
            # not cloned
            if dsnap_lzfs.get(snap):
                lclonename=[clone.name for clone in dsnap_lzfs.get(snap)]
                print_debug('dolly_garbage_collector', 'snap(%s) have clone(%s): skip it' % (snap.name, ','.join(lclonename)))
                continue 
            # not created by dolly
            if snap.duser_prop_value.get('ch.unige:created_by')!=DOLLY_PREFIX :
                print_debug('dolly_garbage_collector', "snap(%s) isn't related to dolly: skip it" % snap.name )
                continue
            # not belonging to this mountpoint
            if mountpoint != "all":
                snap_mnt=snap.duser_prop_value['ch.unige.dolly:mountpoint']
                if snap_mnt!=mountpoint:
                    print_debug('dolly_garbage_collector', "snap(%s) isn't related to the good mountpoint(%s = %s ): skip it" % (snap.name, snap_mnt, mountpoint ) )
                    continue
            # not belonging to this zone
            ZONENAME
            snap_zone=snap.duser_prop_value['ch.unige.dolly:zone']
            if snap_zone != ZONENAME:
                print_debug('dolly_garbage_collector'
                           , "snap(%s) does not belong to this zone(%s) != snap_zone(%s): skip it" % (snap.name, ZONENAME, str(snap_zone)) )
                continue
            # remove the unwanted
            if snap.duser_prop_value['ch.unige.dolly:do_not_keep'] == "yes":
                lsnap_to_destroy.append(snap)              
            # not correct expiration
            expiration_str=snap.duser_prop_value['ch.unige:expiration_datetime']
            expiration_datetime=None
            try:
                expiration_datetime=str2datetime(expiration_str)
            except:
                pass
            if not expiration_datetime:
                expiration_repr=repr(snap.duser_prop_value['ch.unige:expiration_datetime'])
                print_debug('dolly_garbage_collector'
                            ,"snap(%s) does not have a valid expiration(%s): skip it" % (snap.name, expiration_repr))
                continue
            # not expired yet
            now_str=datetime2str(now)
            if now < expiration_datetime:
                print_debug('dolly_garbage_collector'
                            ,"snap(%s) has not expired(now:%s < exp:%s) yet: skip it" % (snap.name, now_str, expiration_str))
                continue
            print_debug('dolly_garbage_collector'
                       ,"snap(%s) has expired(now:%s > exp:%s) yet: add it" % (snap.name, now_str, expiration_str))
            lsnap_to_destroy.append(snap)
        # destroy them
        for snap in lsnap_to_destroy:
            libcbr.zfs.populate_lsnapshot()
            if libcbr.zfs.get_lsnapshot().by_name(snap.name):
                destroy_dolly_snap(snap.name)
        zpool_unlock()
    my_logger.info('stop dolly_garbage_collector')

######################################
#
# class  D O L L Y
#
class DollyError(Exception):
    pass
class DollyErrorAlreadyMounted(DollyError):
    pass
class DollyErrorNotMounted(DollyError):
    pass

class Dolly(object):
    def __init__(self, snapname, mountpoint):
        if not os.path.isdir(DOLLY_PATH):
            os.mkdir(DOLLY_PATH)
        self.snapname=snapname
        self.mountpoint=mountpoint
        self.state='unknown'
        #not yet implemented self.tag=''
        self._lzfs=None
        self._lzpool=None
        self._state=None
    @property
    def state(self):
        return self._state
    @state.setter
    def state(self, state):
        if state not in ['unmounted','mounting','mounted','unmounting', 'unknown']:
            raise ValueError("var state(%s) in class(Dolly) must be in ['unmounted','mounting','mounted','unmounting']" % state)
        self._state=state
    def _get_lock(self, dinfo):
        lockname=self.mountpoint+'.lock'
        self.lock=libcbr.lock.Lock(lockname, dinfo)
        if self.state=='mounting':
            if os.path.isdir(self.mountpoint):
                self.lock=None
                raise DollyErrorAlreadyMounted       
        libcbr.stackfunction.stack_function.add(self._release_lock
                                               ,title='release lock for mountpoint(%s)' % self.mountpoint)
#    def _release_lock(self, is_after_crash=False):
    def _release_lock(self):
        self.lock=None
#        if is_after_crash:
#            self.state='unmounted'
#        else:
#            self.state='mounted'
    @classmethod
    def create_from_demand(self, mountpoint, lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot):
        '''
        create is used to dolly of a zone
        Attention you can not use both arguments isbackup and specific_snapname at the same time
        '''
        my_logger.info("started dolly create_from_demand mountpoint(%s)" % mountpoint)
        # snapname
        snapname=SNAPNAME_FORMAT % {'datetime': datetime2str(datetime.now()) 
                                   ,'zonename': ZONENAME}
        # get the lock
        # do the job
        dolly=Dolly(snapname, mountpoint)

        dolly._snap_clone_n_mount(lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot)
        my_logger.info("ended dolly create_from_demand")
        return dolly
    @classmethod
    def create_from_FS(cls, mountpoint):
        my_logger.info("started dolly create_from_FS mountpoint(%s)" % mountpoint)
        if not os.path.isdir(mountpoint):
            return None
        zfs=libcbr.zfs.get_lzfs().by_path(mountpoint)
        if not zfs:
            msg='unable to create Dolly FS from a mountpoint(%s) where no zfs is mounted' % mountpoint
            my_logger.warning(msg)
            raise DollyErrorNotMounted(msg)
        lmount=libcbr.mount.get_lmount(under_path=mountpoint)
        lsnapname=[]
        for mount in lmount:
            zfs=libcbr.zfs.get_lzfs().by_name(mount.device_to_mount)
            if not zfs:
                msg="unable to create Dolly FS from a mountpoint(%s) where a fs(%s) is not a zfs" %(mountpoint, mount.device_to_mount)
                my_logger.error(msg)
                raise DollyErrorNotMounted(msg)
            if zfs.duser_prop_value.get('ch.unige.dolly:mountpoint')!=mountpoint:
                msg="unable to create Dolly FS from a mountpoint(%s) where the user property 'ch.unige.dolly:mountpoint' is not the mountpoint itself " %(mountpoint)
                my_logger.error(msg)
                raise DollyErrorNotMounted(msg)
            if zfs.duser_prop_value.get('ch.unige:created_by')!=DOLLY_PREFIX:
                msg="unable to create Dolly FS from a mountpoint(%s) where the user property 'ch.unige:created_by' is not dolly" %(mountpoint)
                my_logger.error(msg)
                raise DollyErrorNotMounted(msg)
                continue
            if not zfs.origin:
                msg="unable to create Dolly FS from a mountpoint(%s) where the zfs(%s) is not issued of a snapshot" %(mountpoint, zfs.name)
                my_logger.error(msg)
                raise DollyErrorNotMounted(msg)
                continue
            if zfs.origin.duser_prop_value.get('ch.unige:created_by')!=DOLLY_PREFIX:
                msg="unable to create Dolly FS from a mountpoint(%s) where the snap user property ch.unige:created_by' is not dolly" %(mountpoint)
                my_logger.error(msg)
                raise DollyErrorNotMounted(msg)
                continue
            lsnapname.append(zfs.origin.snapname)
        lsnapname=list(set(lsnapname))
        if not lsnapname:
            msg="unable to create Dolly FS from a mountpoint(%s) : no snapname found" %(mountpoint)
            my_logger.error(msg)
            raise DollyErrorNotMounted(msg)
        if len(lsnapname) > 1:
            msg="unable to create Dolly FS from a mountpoint(%s) : more than one snapname(%s) found" %(mountpoint,",".join(lsnapname) )
            my_logger.error(msg)
            raise DollyErrorNotMounted(msg)
        snapname=lsnapname[0]
        dolly=Dolly(snapname, mountpoint)
        my_logger.info("ended dolly create_from_FS")
        return dolly
    def replicate(self, tag=None, expiration_datetime=None):
        #TODO: create_from_FS
        pass
    def _snap_clone_n_mount(self, lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot ):
        #
        #
        my_logger.info("started dolly _snap_clone_n_mount")

        dinfo={'mountpoint':self.mountpoint
              ,'snapname':self.snapname
              ,'lzfs_2_clone': ",".join([zfs.name for zfs in lzfs_2_clone])
              ,'state' : 'snap_clone_n_mount'}
        self._get_lock(dinfo)
        #
        # prepare the umount in case of failure
        dolly=None
        try:
            dolly=self.create_from_FS(self.mountpoint)
        except DollyErrorNotMounted :
            pass
        if dolly:
            msg="can not clone on this mountpoint(%s) a clone is already here" % self.mountpoint
            my_logger.warning(msg)
            print msg
            sys.exit(1)
        if os.path.isfile(self.mountpoint) or os.path.isdir(self.mountpoint):
            msg="can not clone on this mountpoint(%s): file or dir already exist" % self.mountpoint
            my_logger.warning(msg)
            sys.exit(1)
#        reason_for_umount='_snap_clone_n_mount ^C or kill -15 for zone(%s) mountpoint(%s)' % (self.zone.zonename, self.mountpoint_reldir)
#        fun_umount=libcbr.stackfunction.stack_function.add(self.zone.dolly_usual_umount,
#                                                          [],
#                                                          {'reason':reason_for_umount},
#                                                          title='umount zone(%s), mountpoint_reldir(%s)' % (self.zone.zonename,
#                                                                                                            self.mountpoint_reldir))
        #
        # snapshot
        self._snap(snapshot_expiration, lzfs_2_clone, lzfs_dontkeepsnapshot)
        # clone & mount 
        my_logger.debug('clone  & mount dolly')
        self._clone_n_mount(snapshot_expiration, lzfs_2_clone)
        #
        # release the lock
        self._release_lock()
        #
        #        fun_umount.delete()
        my_logger.info("ended dolly _snap_clone_n_mount")
    def _snap(self, snapshot_expiration, lzfs_2_clone, lzfs_dontkeepsnapshot):
        my_logger.info("started dolly _snap(%s)" % self.snapname)
        #
        # snapshot lzpool recursively
        my_logger.debug('snapshot lzpool recursively')
        lzpool=list(set([zfs.zpool for zfs in lzfs_2_clone]))
        lzpoolname=[zpool.name for zpool in lzpool]
        if len(lzpoolname)>1:
            msg="the zone(%s) has more that one zpool(%s), all the data won't be syncronized" \
                    % (ZONENAME, ','.join(lzpoolname) )
            my_logger.warning(msg)
        for zpool in lzpool:
            zfs_of_zpool=libcbr.zfs.get_lzfs().by_name(zpool.name)
            doption={'ch.unige:expiration_datetime': datetime2str(snapshot_expiration)
                    ,'ch.unige:created_by': DOLLY_PREFIX
                    ,'ch.unige.dolly:zone': ZONENAME
                    ,'ch.unige.dolly:mountpoint': self.mountpoint}
            zfs_of_zpool.do_snapshot(self.snapname, isrecursive=True, doption=doption)
        #
        # refresh
        libcbr.zfs.populate_lzfs()
        libcbr.zfs.populate_lsnapshot()
        lsnap=libcbr.zfs.get_lsnapshot().by_snapname(self.snapname)
        #
        # add the property "ch.unige.dolly:do_not_keep_snapshot
        my_logger.debug('Is there some snapshots which we wont keep')
        lzfsname_dontkeepsnapshot=[zfs.name for zfs in lzfs_dontkeepsnapshot]
        for snap in lsnap:
            if snap.zfs.name in lzfsname_dontkeepsnapshot:
                libcbr.zfs.set_prop_value("ch.unige.dolly:do_not_keep", "yes", snap.name)
        #
        # remove snapshots which will not be used for cloning
        my_logger.debug('Is there some snapshots which will not be used for cloning')
        lsnapname=[snap.name for snap in lsnap]
        #
        lsnapshotname_necessary=["%s@%s" % (zfs.name, self.snapname) for zfs in lzfs_2_clone]
        lsnapname_to_destroy=list( set(lsnapname)-set(lsnapshotname_necessary) )
        #
        if lsnapname_to_destroy:
            my_logger.debug('destroy them')
            for snap in lsnapname_to_destroy:
                libcbr.zfs.destroy(snap)
            my_logger.debug('unnecessary snapshot destroyed')
        #
        #
        my_logger.info('ended dolly _snap')     
    def _clone_n_mount(self, snapshot_expiration, lzfs):
        my_logger.info("started dolly _clone_mount snapname(%s), mountpoint(%s)" % (self.snapname
                                                                           ,self.mountpoint))
        #
        # prepare the umount in case of failure
        fun_umount=libcbr.stackfunction.stack_function.add(self.unmount_n_unclone,
                                                          title='unmount_n_unclone')
        #
        # sort lfs_info, to clone and mount. The mounting process must start to mount
        # the shortest path first
        #
        lzfs.sort(libcbr.zfs.Zfs.cmp_by_mountpoint_from_lmount)
        print_debug('_clone_n_mount', 'show zfs order')
        for zfs in lzfs:
            print_debug('_clone_n_mount', 'zfs name    :', zfs.name)
            print_debug('_clone_n_mount', '  mountpoint:', zfs.get_mountpoint_from_lmount())
        lzfsname=[]
        for zfs in lzfs:
            mountpoint=os.path.join(self.mountpoint, zfs.get_mountpoint_from_lmount()[1:])
            mountpoint=os.path.normpath(mountpoint)
            hash4newzfsname=os.path.basename(self.mountpoint)
            new_zfsname="%s/%s_%s_%s"%(zfs.name, DOLLY_PREFIX, hash4newzfsname, ZONENAME)
            new_zfsname=os.path.normpath(new_zfsname)
            new_zfsname=libcbr.path.rstrip_slash(new_zfsname)
            snapshot_expiration_str=datetime2str(snapshot_expiration)
            # debug
            print_debug('_clone_n_mount', 'zfs.mountpoint',  zfs.get_mountpoint_from_lmount())
            print_debug('_clone_n_mount', ' zfs.name', zfs.name)
            print_debug('_clone_n_mount', ' snapname', self.snapname)
            print_debug('_clone_n_mount', ' new_zfsname', new_zfsname)
            print_debug('_clone_n_mount', ' new_mountpoint', mountpoint)
            print_debug('_clone_n_mount', ' expiration',snapshot_expiration_str)
            print_debug('_clone_n_mount', '2 new_zfsname',  new_zfsname)
            #
            #mount also the clonelzfs_dontkeepsnapshot
            doption={'mountpoint':mountpoint
                     ,'ch.unige:created_by': DOLLY_PREFIX
                     ,'ch.unige.dolly:zone' : ZONENAME
                     ,'ch.unige:no_snapshots': 'on' # used by other sipt to tell that dolly clone MUST not be snapshoted
                     ,'ch.unige.dolly:mountpoint' : self.mountpoint}
            snapshot_name="%s@%s" % (zfs.name, self.snapname)
            libcbr.zfs.clone_zfs(snapshot_name, new_zfsname, doption=doption)
            lzfsname.append(new_zfsname)
        lzfsname.reverse()
        for zfsname in lzfsname:
            libcbr.zfs.set_prop_value('readonly','on',zfsname)
        fun_umount.delete()
        my_logger.info("ended dolly clone_mount")
    def unmount_n_unclone(self):
        my_logger.info('unmount_n_unclone mountpoint(%s)' % self.mountpoint )
        #
        # repopulate all
        libcbr.zfs.populate_lzfs()
        libcbr.zfs.populate_lzpool()
        libcbr.zfs.populate_lsnapshot()
        libcbr.mount.populate_lmount()
        #
        dinfo={'mountpoint':self.mountpoint
              ,'state' : 'unmount_n_unclone'}
        self._get_lock(dinfo)
        #
        # get the list of the ZFS clone mounted under this path       
        lmount=libcbr.mount.get_lmount(under_path=self.mountpoint)
        print_debug('unmount_n_unclone', '--------- LMOUNT------------------')
        for mount in lmount:
                    print_debug('unmount_n_unclone', mount.device_to_mount )
        print_debug('unmount_n_unclone', '----------------------------------')
        lzfs=[]
        for mount in lmount:
            zfs=libcbr.zfs.get_lzfs().by_name(mount.device_to_mount)
            lzfs.append(zfs)
        #
        # umount the ZFS clone
        lzfs.sort(libcbr.zfs.Zfs.cmp_by_mountpoint_from_lmount)
        lzfs.reverse()
        print_debug('unmount_n_unclone', '--------- LZFS------------------')
        for zfs in lzfs:
                    print_debug('unmount_n_unclone', zfs.name )
        print_debug('unmount_n_unclone', '----------------------------------')
        if lzfs:
            my_logger.debug('unmount zfs(%s)' % ', '.join( [zfs.name for zfs in lzfs ]) )
        for zfs in lzfs:
            zfs.unmount()
        #
        # destroy the mountpoint
        ldir=[]
        for (path, unused_dirs, unused_files) in os.walk(self.mountpoint):
            ldir.append(libcbr.path.CPath(path))
        ldir.sort()
        ldir.reverse()
        for dir_to_remove in ldir:
            os.rmdir(dir_to_remove)
        #
        # unclone the ZFS clone
        lzfs.sort(libcbr.zfs.Zfs.cmp_by_name)
        lzfs.reverse
        for zfs in lzfs:
            libcbr.zfs.destroy(zfs.name)
        #
        # ending
        self._release_lock()    
        my_logger.info('unmount_n_unclone done' )

_ldolly_mnt=[]
_lmap_mountpoint_snap=[]
_do_populate_ldolly=True
def get_ldolly_mnt():
    #        
    if _do_populate_ldolly==True:
        populate_ldolly_mnt_n_snap()
    lret=_ldolly_mnt[:]
    return lret

def get_lmap_mountpoint_snap():
    #        
    if _do_populate_ldolly==True:
        populate_ldolly_mnt_n_snap()
    lret=_lmap_mountpoint_snap[:]
    return lret

def populate_ldolly_mnt_n_snap():
    my_logger.debug('refresh zfs.populate_lsnapshot')
    global _ldolly_mnt
    global _lmap_mountpoint_snap
    global _do_populate_ldolly
    #
    #TODO : get the lock
    pass
    # refresh the data
    libcbr.zfs.populate_lzfs()
    libcbr.zfs.populate_lzpool()
    libcbr.zfs.populate_lsnapshot()
    libcbr.mount.populate_lmount()
    #
    ldolly_mountpoint=[]
    for zfs in libcbr.zfs.get_lzfs():
        if not is_created_by_dolly(zfs):
            print_debug('populate_ldolly', 'mnt: zfs(%s) not created by dolly : skip it' % zfs.name)
            continue
        #---
        if not is_zfs_mounted(zfs):
            print_debug('populate_ldolly', 'mnt: zfs(%s) is not mounted : skip it' % zfs.name)
            continue
        #---
        dolly_mountpoint=zfs.duser_prop_value.get('ch.unige.dolly:mountpoint')
        if not dolly_mountpoint:
            print_debug('populate_ldolly', 'mnt: zfs(%s) as not a "ch.unige.dolly:mountpoint" : skip it' % zfs.name)
            continue
        #---
        if is_on_a_zone_when_in_globalzone(zfs):
            print_debug('populate_ldolly', 'mnt: zfs(%s) does not belong to this zone : skip it' % zfs.name)
            continue
        #---
        print_debug('populate_ldolly', 'mnt: add dolly_mountpoint(%s) : add it' % dolly_mountpoint)
        ldolly_mountpoint.append(dolly_mountpoint)
    ldolly_mountpoint=list(set(ldolly_mountpoint))
    _ldolly_mnt=[Dolly.create_from_FS(dolly_mountpoint) for dolly_mountpoint in ldolly_mountpoint]
    #
    #
    _lmap_mountpoint_snap=[]
    dsnap_lzfs={}
    for zfs in libcbr.zfs.get_lzfs():
        if zfs.origin:
            if dsnap_lzfs.get(zfs.origin):
                dsnap_lzfs.append(zfs)
            else:
                dsnap_lzfs[zfs.origin]=[zfs]
    for snap in libcbr.zfs.get_lsnapshot():
        if not is_created_by_dolly(snap):
            print_debug('populate_ldolly', 'snap: snap(%s) not created by dolly : skip it' % snap.name)
            continue
        dolly_mountpoint=snap.duser_prop_value.get('ch.unige.dolly:mountpoint')
        if not dolly_mountpoint:
            print_debug('populate_ldolly', 'snap: snap(%s) as not a "ch.unige.dolly:mountpoint" : skip it' % snap.name)
            continue
        if dsnap_lzfs.get(snap): 
            print_debug('populate_ldolly', 'snap: snap(%s) a clone depending on it : skip it' % snap.name)
            continue
        if is_on_a_zone_when_in_globalzone(snap.zfs):
            print_debug('populate_ldolly', 'snap: zfs(%s) does not belong to this zone : skip it' % zfs.name)
            continue
        print_debug('populate_ldolly', 'snap: add dolly_snapshot(%s) : add it' % snap.name)
        _lmap_mountpoint_snap.append((dolly_mountpoint, snap))
    _lmap_mountpoint_snap=list(set(_lmap_mountpoint_snap))
    #
    _do_populate_ldolly=False

def clone(mountpoint, lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot):
    dolly_garbage_collector(datetime.now(), mountpoint)
    dolly_clean=libcbr.stackfunction.stack_function.add(dolly_garbage_collector
                                                       ,args= (datetime.now(), mountpoint)                                      
                                                       ,title="dolly_garbage_collector")
    unused_dolly=Dolly.create_from_demand(mountpoint, lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot)
    dolly_clean()

def kill(mountpoint):
    dolly=Dolly.create_from_FS(mountpoint)
    if not dolly:
        dolly_garbage_collector(datetime.now(), mountpoint)
        msg="unable to kill a dolly not mounted(%s), not a dolly" % mountpoint
        my_logger.error(msg)
        print msg
        sys.exit(2)
    dolly_clean=libcbr.stackfunction.stack_function.add(dolly_garbage_collector
                                                       ,args= (datetime.now(), mountpoint)                                      
                                                       ,title="dolly_garbage_collector")
    dolly.unmount_n_unclone()
    dolly_clean()

def list_dolly():
    lmnt=get_ldolly_mnt()
    lsnapname_active=[]
    if lmnt:
        print "mounted :"
        for dolly in lmnt:
            print "mounted %s @%s" % (dolly.mountpoint, dolly.snapname)
            lsnapname_active.append(dolly.snapname)
    #
    lmap_mountpoint_snap=get_lmap_mountpoint_snap()
    lmnt=list(set([mountpoint for mountpoint, snap in lmap_mountpoint_snap]))
    lmnt.sort(libcbr.mix.cmpAlphaNum)
    l2print=[]
    if lmap_mountpoint_snap:
        for mnt in lmnt:
            is_show_mountpoint = True
            lsnapname=list(set([snap.snapname for mountpoint, snap in lmap_mountpoint_snap if mountpoint == mnt]))
            lsnapname=[snapname for snapname in lsnapname if not snapname in lsnapname_active]
            lsnapname.sort(libcbr.mix.cmpAlphaNum)
            for snapname in lsnapname:
                line=" %s @%s" % (mnt if is_show_mountpoint else " " * len(mnt),snapname)
                l2print.append(line)
                is_show_mountpoint = False
    if l2print:
        print "snapshot kept :"
        print os.linesep.join(l2print)


def lzpool_2_lzfs(zpoolname_str, lzpoolname_error=[]):
    lzpoolname=zpoolname_str.split(",")
    lzfs=[]
    for zpoolname in lzpoolname:
        if not zpoolname:
            continue
        zpool=libcbr.zfs.get_lzpool().by_name(zpoolname)
        if zpool:
            for zfs in zpool.lzfs:
                if is_zfs_eligible(zfs):
                    lzfs.append(zfs)
        else:
            lzpoolname_error.append(zpoolname)
    return lzfs, lzpoolname_error

def lzfs_path_2_lzfs(zfspath_str, lzfspath_error=[]):
    lzfs_path=zfspath_str.split(",")
    lzfs=[]
    for zfspath in lzfs_path:
        if not zfspath:
            continue
        zfs=libcbr.zfs.get_lzfs().by_path(zfspath)
        if zfs:
            if is_zfs_eligible(zfs):
                lzfs.append(zfs)
                continue
        lzfspath_error.append(zfspath)
    return lzfs, lzfspath_error

#
# the main function
#
if '__main__' == __name__:
    from optparse import OptionParser
    parser = OptionParser(usage='''
    %prog clone [--mountpoint=<path>] [--snapshot-expiration-datetime=<iso8601>]
                [--zfs-dir-incl=<path>,...] [--zfs-dir-excl=<path>,...]
                [--sub-zfs-dir-incl=<path>,...] [--sub-zfs-dir-excl=<path>,...]
                [--zpool-name-incl=<path>,...] [--zpool-name-excl=<path>,...]
                [--zfs-dir-dont-keep-snapshot=<path>,...] [--sub-zfs-dir-dont-keep-snapshot=<path>,...]
    %prog kill [--mountpoint=<path>]
    %prog destroy-old-snapshot-kept [--mountpoint=all|<path>] [--as-we-were-in=<iso8601>]
    
    more info on : https://github.com/briner/dolly/blob/master/dolly/README''')
    parser.add_option("--mountpoint",                      dest="mountpoint",      default=DEFAULT_MOUNTPOINT
                     ,help='under which path the clone is (default:"%s")' % DEFAULT_MOUNTPOINT)
    # -- clone or kill
    parser.add_option("--sub-zfs-dir-incl",                dest="subzfsdirincl",   default=SUB_ZFS_DIR_INCL
                     ,help='to include to the clone a subtree of the VFS. the value MUST be a zfs mountpoint,... (default:"%s")' % SUB_ZFS_DIR_INCL)
    parser.add_option("--sub-zfs-dir-excl",                dest="subzfsdirexcl",   default=SUB_ZFS_DIR_EXCL
                     ,help='to exclude to the clone a subtree of the VFS. the value MUST be a zfs mountpoint,... (default:"%s")' % SUB_ZFS_DIR_EXCL)
    #
    parser.add_option("--zfs-dir-excl",                    dest="zfsdirexcl",      default=ZFS_DIR_EXCL
                     ,help='to include to the clone a ZFS. the value MUST be a zfs mountpoint,... (default:"%s")' % ZFS_DIR_EXCL)
    parser.add_option("--zfs-dir-incl",                    dest="zfsdirincl",      default=ZFS_DIR_INCL
                     ,help='to exclude to the clone a ZFS. the value MUST be a zfs mountpoint,... (default:"%s")' % ZFS_DIR_INCL)
    #
    parser.add_option("--zpool-name-excl",                    dest="zpoolnameexcl",      default=ZFS_DIR_EXCL
                     ,help='to include to the clone every the zfs of a ZPOOL. the value MUST be a zpool name,... (default:"%s")' % ZPOOL_NAME_EXCL)
    parser.add_option("--zpool-name-incl",                    dest="zpoolnameincl",      default=ZFS_DIR_INCL
                     ,help='to exclude to the clone every ZFS of a ZPOOL. the value MUST be a zpool name,... (default:"%s")' % ZPOOL_NAME_INCL)
    #
    parser.add_option("--zfs-dir-dont-keep-snapshot",      dest="zfsdir_dontkeepsnapshot", default=ZFS_DIR_DONT_KEEP_SNAPSHOT
                     ,help='zfs dir for which we will not keep the snapshot, the value MUST be a mountpoint,... (default:"%s")' % ZFS_DIR_DONT_KEEP_SNAPSHOT)
    parser.add_option("--sub-zfs-dir-dont-keep-snapshot",  dest="subzfsdir_dontkeepsnapshot", default=SUB_ZFS_DIR_DONT_KEEP_SNAPSHOT
                     ,help='zfs dir for which we will not keep the snapshot, the value MUST be a mountpoint,... (default:"%s")' % SUB_ZFS_DIR_DONT_KEEP_SNAPSHOT)
    # -- destroy-old-snapshot-kept
    parser.add_option("--snapshot-expiration-datetime",    dest="expiration_str",  default=DEFAULT_SNAPSHOT_ISO8601_STR
                     ,help='the time we will keep the snapshot after the cloning (default:"%s")' % DEFAULT_SNAPSHOT_ISO8601_STR)
    parser.add_option("--as-we-were-in",                   dest="another_now",     default=None
                     ,help='expiration or duration in <iso8601> format. (eg: duration of 5day:"P5D", of 5min:"PT5M", at datetime 2012.09.1975:"1975-08-19" )')
    # -- commun
    parser.add_option("-v", "--verbose",                   dest="isverbose",       default=False, action="store_true")    
    parser.add_option("--no-email",                        dest="send_email",
                      action="store_false", help='do not send any email')
    parser.add_option("-d", "--debug",   action="store_true",  dest="debug",       default=False
                     ,help='increase the level of debugging')
    (options, args) = parser.parse_args()
    #
    #
    def print_help_n_exit(msg=None):
        parser.print_help()
        if msg:
            print ''
            print msg 
        sys.exit(1)
    #
    #
    must_debug=False
    #
    # Do we need to rotate the log
    laction=[]
    is_usage_well_formated=True
    lmsg4error_parser=[]
    #
    signal.signal(signal.SIGINT,  libcbr.stackfunction.stack_function.terminate)
    signal.signal(signal.SIGTERM, libcbr.stackfunction.stack_function.terminate)
    try:
        #
        # enable the log
        can_be_verbose=True
        if options.debug or DEBUG:
            must_debug=True
        is_verbose=False
        if options.isverbose and can_be_verbose:
            is_verbose=True
        libcbr.log.logger.enable_it(is_verbose, must_debug, LOG_FILENAME)
        my_logger.info('dolly start in the __main__ place')
        #
        # parse the arguments
        #--- another_now
        another_now=datetime.now()
        if options.another_now:
            datetime_or_duration=iso8601_parse(options.another_now)
            if isinstance(datetime_or_duration, relativedelta):
                another_now=datetime.now()+datetime_or_duration
            if isinstance(datetime_or_duration, datetime):
                another_now=datetime_or_duration            
            if another_now < datetime.now():
                print_help_n_exit('--as-we-were-in can not point to the past')
        #--- snapshot_expiration
        snapshot_expiration=None
        expiration_or_duration=iso8601_parse(options.expiration_str)
        if isinstance(expiration_or_duration, relativedelta):
            snapshot_expiration=datetime.now()+expiration_or_duration
        if isinstance(expiration_or_duration, datetime):
            snapshot_expiration=expiration_or_duration            
        if snapshot_expiration < datetime.now():
            print_help_n_exit('--snapshot-expiration-datetime(%s) can not point to the past' % options.expiration_str)
        if not snapshot_expiration:
            print_help_n_exit('--snapshot-expiration-datetime error')
        #--- list of zfs     
        lzfspath_error=[]
        lzpoolname_error=[]
        lzfsincl,    lzfspath_error = lzfs_path_2_lzfs(options.zfsdirincl,    lzfspath_error)
        lzfsexcl,    lzfspath_error = lzfs_path_2_lzfs(options.zfsdirexcl,    lzfspath_error)
        lsubzfsincl, lzfspath_error = lzfs_path_2_lzfs(options.subzfsdirincl, lzfspath_error)
        lsubzfsexcl, lzfspath_error = lzfs_path_2_lzfs(options.subzfsdirexcl, lzfspath_error)
        lzfsincl_of_zpoolname,lzpoolname_error=lzpool_2_lzfs(options.zpoolnameincl, lzpoolname_error)
        lzfsexcl_of_zpoolname,lzpoolname_error=lzpool_2_lzfs(options.zpoolnameexcl, lzpoolname_error)
        if lzfspath_error:
            msg="this zfs path(%s) are not a mountpoint for a zfs, this can not be used for parameter in --*-zfs-*" % ",".join(lzfspath_error)
            print_help_n_exit(msg)
        if lzpoolname_error:
            msg="this zpool name(%s) are not a zpool name, this can not be used for parameter in --zpool--*" % ",".join(lzpoolname_error)
            print_help_n_exit(msg)
        #
        set_zfs2clone=set(lzfsincl+lzfsincl_of_zpoolname)
        for subzfsincl in lsubzfsincl:
            ltmpzfs=libcbr.zfs.get_lzfs().under_path(subzfsincl.get_mountpoint_from_lmount())
            ltmpzfs=filter(is_zfs_eligible,ltmpzfs)
            set_zfs2clone=set_zfs2clone.union(set(ltmpzfs))
        for subzfsexcl in lsubzfsexcl:
            ltmpzfs=libcbr.zfs.get_lzfs().under_path(subzfsexcl.get_mountpoint_from_lmount())
            ltmpzfs=filter(is_zfs_eligible,ltmpzfs)
            set_zfs2clone=set_zfs2clone-set(ltmpzfs)
        lzfs_2_clone=list(set_zfs2clone-set(lzfsexcl+lzfsexcl_of_zpoolname))
        if not lzfs_2_clone:
            msg="no zfs to clone with this parameter"
            print_help_n_exit(msg)
        #--
        set_zfs_dontkeepsnapshot= set(lzfs_path_2_lzfs(options.zfsdir_dontkeepsnapshot)[0])
        lsubzfs_dontkeepsnapshot= lzfs_path_2_lzfs(options.subzfsdir_dontkeepsnapshot)[0]
        for subzfs_dontkeepsnapshot in lsubzfs_dontkeepsnapshot:
            ltmpzfs=libcbr.zfs.get_lzfs().under_path(subzfs_dontkeepsnapshot.get_mountpoint_from_lmount())
            set_zfs_dontkeepsnapshot=set_zfs_dontkeepsnapshot.union(set(ltmpzfs))
        lzfs_dontkeepsnapshot=list(set_zfs_dontkeepsnapshot)
        #---
        if len(args)==0:
            list_dolly()
        elif args[0]=="clone":          # dolly create  [--mountpoint=<path>]
            if (options.another_now) or (len(args) >2):
                print_help_n_exit()
            clone(options.mountpoint, lzfs_2_clone, snapshot_expiration, lzfs_dontkeepsnapshot)
        elif args[0]=="kill":         # dolly destroy [--mountpoint=<path>]
            if (options.another_now) or (len(args) >2):
                print_help_n_exit()
            kill(options.mountpoint)
        elif args[0]=="destroy-old-snapshot-kept":     # destroy-old-snapshot-kept [--mountpoint=<path>]  [--as-we-were-in=<iso8601>]
            if len(args) > 2:
                print_help_n_exit()
            dolly_garbage_collector(another_now, options.mountpoint)
        else:
            print_help_n_exit()
    except SystemExit, inst_system_exit:
        raise inst_system_exit
    except:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        tb_format_exception=traceback.format_exception(exc_type, exc_value
                                                       ,exc_traceback)
        libcbr.log.logger.is_stdout_enabled=True
        my_logger.error('started error in dolly, freeing resources:')
        libcbr.stackfunction.stack_function.terminate_group()
        my_logger.error('ended error in dolly, freeing resources')
        lmsg=[]
        lmsg.append('Error Stack will follow:')
        for line in tb_format_exception:
            lmsg.append(' %s' % line)
        #
        [my_logger.error(msg) for msg in lmsg]
        #
        sys.exit(1)
    sys.exit()
                